есть 2 варианта, что возможно распараллелить:
1) алгоритм формирования треугольной матрицы L, U
  тут важно заметить, что распараллеливание самого верхнего цикла невозможно, получается неверный результат.
  что касается распараллеливания матриц, тут можно распараллелить по строкам, так как они независимы друг от друга. Написание распараллеливания 2х функций в одной подпрограмме возможно по той причине, что распараллеливание происходит лишь для расчета строк матриц, а при этом порядок расчета матриц неизменен.

2) распаралелить вычисление суммы
  Но тут важно понимать, что в одну ячейку возможна запись нескольких потоков, поэтому необходима синхронизация в виде reduction?


static - он разделяет задачи поровну между потоками
 Подходит,когда время на выполнение операций одинаково
 Нет расходов на распределение итераций


dynamic - распределяет в зависимости от нагруженности. То есть выполняет, возвращает результат и забирает новую задачу из очереди
 Подходит, когда время выполнения различное
 Есть расходы - занимается распределением итераций

guided - как и dynamic, но отличие в том, что он блоки делит не от кол-ва, а от непройденных итераций

runtime 

auto
