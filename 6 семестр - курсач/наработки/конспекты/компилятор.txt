   1 этап: лексический анализатор
у нас несколько массивов(таблиц):
   - таблица терминалов  |
   - таблица чисел       | => внутренние таблицы
   - таблица переменных  |
   
   - таблица лексем 

Мы проходим весь код программы и записываем, то что встречаем
в таблицы. 

у нас таблица лексем состоит из массива структур. В структуре
описан тип, индекс и значение. 
Когда мы находим кодовое слово, то сраниваем с таблицей
кодовых слов и возвращаем номер, где оно находится.
Когда же мы находим другую лексему, то мы дропаем ее в 
соответсыующую внутренннию таблицу. И оттуда получаем ее номер.
Добавляем в конец (push_back), а чтобы узнать индекс - size() ?

И потом эта таблица лексем переходит для синтаксического анализа
То есть эта таблица должна быть public. 
Лучше добавить 3 публичных метода:
 - current_token (он возвращает текущий токен из массива)
    тут создать current_token_index, который изначально равен 0, потом +1
 - next_token ( передвигается на следующий токен)
    current_token_index +1
 -current_token_type (возвращает тип токена)

   2 этап: синтаксический анализатор
для построения нужно абстрактное синтаксическое дерево

тут класс узла, который состоит из типа, значения и потомков. 
Сделать конструктор со значения по умолчанию = nullptr
создать типы узлов (enum class)
{
  prog - начальный узел всей проги
  expr - начальный узел для выражения
  
  const - любое число
  add - слож
  sub - вычит
  mul - умнож
  div - дел
}

класс для дерева
 в конструкторе по умолчанию 0, так как начианем с вершины
 там еще дескриптор (? - он так называется) - нужно организовать очистку дерева

 потом метод печати(лн рекурсивный)
 в нем проверяем равен ли текущий узел 0, если да, тоо выходим из функции
потом в функции у нас есть параметр уровень, он необходим для того, чтобы 
выводит пробелы (это красота)
так как типы, которые нам возвращаются - числа, то нужен case, который позволит вывести дерево в формате букв(кодовых слов). Если это константа или переменная, то запрашиваем имя
А потом зарекурсируем функцию. То есть вызываем эту же функцию, но для потомка 1,2,3,4 и так дале и добаляем уровень вывода.

потом отдельная функция вывод, в которой вызываем функцию рекурсивного вывода дерева со значениями. Тут мем в том, что вывод - public, а рекурсивный вывод - private

Тут еще класс парсера
Забираем лексер и дерево из заголовков
Потом конструктор. 

метод парсинга. Тут нужно забрать метод сплит у лексера
метод ошибки.

и добавлеям функции с возвращаем значением узла.


  3 этап: семантический анализ
он заключается в том, что мы несколько раз проходимся по дереву?

  4 этап: генерация кода
Я думаю
  мы успользуем таблицу констант, чтобы  вначале файла написать это. 
  потом переменные, чтобы тоже их задать

  




