
test_base.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__ctors_end>
   4:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
   8:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
   c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  10:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  14:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  18:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  1c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  20:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  24:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  28:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  2c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  30:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  34:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  38:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  3c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  40:	0c 94 ff 01 	jmp	0x3fe	; 0x3fe <__vector_16>
  44:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  48:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  4c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  50:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  54:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  58:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  5c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  60:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
  64:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>

00000068 <__trampolines_end>:
  68:	00 00       	nop
  6a:	00 00       	nop
  6c:	24 00       	.word	0x0024	; ????
  6e:	27 00       	.word	0x0027	; ????
  70:	2a 00       	.word	0x002a	; ????

00000072 <port_to_output_PGM>:
  72:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

0000007c <port_to_input_PGM>:
  7c:	00 00 00 00 23 00 26 00 29 00                       ....#.&.).

00000086 <digital_pin_to_port_PGM>:
  86:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
  96:	03 03 03 03                                         ....

0000009a <digital_pin_to_bit_mask_PGM>:
  9a:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
  aa:	04 08 10 20                                         ... 

000000ae <digital_pin_to_timer_PGM>:
  ae:	00 00 00 08 00 02 01 00 00 03 04 07 00 00 00 00     ................
  be:	00 00 00 00                                         ....

000000c2 <__ctors_end>:
  c2:	11 24       	eor	r1, r1
  c4:	1f be       	out	0x3f, r1	; 63
  c6:	cf ef       	ldi	r28, 0xFF	; 255
  c8:	d8 e0       	ldi	r29, 0x08	; 8
  ca:	de bf       	out	0x3e, r29	; 62
  cc:	cd bf       	out	0x3d, r28	; 61

000000ce <__do_copy_data>:
  ce:	11 e0       	ldi	r17, 0x01	; 1
  d0:	a0 e0       	ldi	r26, 0x00	; 0
  d2:	b1 e0       	ldi	r27, 0x01	; 1
  d4:	e0 ec       	ldi	r30, 0xC0	; 192
  d6:	f8 e0       	ldi	r31, 0x08	; 8
  d8:	02 c0       	rjmp	.+4      	; 0xde <__do_copy_data+0x10>
  da:	05 90       	lpm	r0, Z+
  dc:	0d 92       	st	X+, r0
  de:	a2 30       	cpi	r26, 0x02	; 2
  e0:	b1 07       	cpc	r27, r17
  e2:	d9 f7       	brne	.-10     	; 0xda <__do_copy_data+0xc>

000000e4 <__do_clear_bss>:
  e4:	21 e0       	ldi	r18, 0x01	; 1
  e6:	a2 e0       	ldi	r26, 0x02	; 2
  e8:	b1 e0       	ldi	r27, 0x01	; 1
  ea:	01 c0       	rjmp	.+2      	; 0xee <.do_clear_bss_start>

000000ec <.do_clear_bss_loop>:
  ec:	1d 92       	st	X+, r1

000000ee <.do_clear_bss_start>:
  ee:	ab 30       	cpi	r26, 0x0B	; 11
  f0:	b2 07       	cpc	r27, r18
  f2:	e1 f7       	brne	.-8      	; 0xec <.do_clear_bss_loop>
  f4:	0e 94 49 02 	call	0x492	; 0x492 <main>
  f8:	0c 94 5e 04 	jmp	0x8bc	; 0x8bc <_exit>

000000fc <__bad_interrupt>:
  fc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000100 <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)

case TIMER1A: 
 100:	83 30       	cpi	r24, 0x03	; 3
 102:	81 f0       	breq	.+32     	; 0x124 <turnOffPWM+0x24>

!= TIMER1A
 104:	28 f4       	brcc	.+10     	; 0x110 <turnOffPWM+0x10>

case TIMER1B: 
 106:	81 30       	cpi	r24, 0x01	; 1
 108:	99 f0       	breq	.+38     	; 0x130 <turnOffPWM+0x30>

case TIMER1С:
 10a:	82 30       	cpi	r24, 0x02	; 2
 10c:	a9 f0       	breq	.+42     	; 0x138 <turnOffPWM+0x38>

 10e:	08 95       	ret

case  TIMER2: 
 110:	87 30       	cpi	r24, 0x07	; 7
 112:	a9 f0       	breq	.+42     	; 0x13e <turnOffPWM+0x3e>

case TIMER0A:
 114:	88 30       	cpi	r24, 0x08	; 8
 116:	c9 f0       	breq	.+50     	; 0x14a <turnOffPWM+0x4a>

case !=TIMER0B:
 118:	84 30       	cpi	r24, 0x04	; 4
 11a:	b1 f4       	brne	.+44     	; 0x148 <turnOffPWM+0x48>
	
t = TIMER0B;
t & 223;
goto pereadres;		
 11c:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
 120:	8f 7d       	andi	r24, 0xDF	; 223
 122:	03 c0       	rjmp	.+6      	; 0x12a <turnOffPWM+0x2a>

COM1A1:
 124:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
 128:	8f 77       	andi	r24, 0x7F	; 127
		

COM1A1 = t; pereadres:
 12a:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
 12e:	08 95       	ret

COM1B1:		
 130:	84 b5       	in	r24, 0x24	; 36
 132:	8f 77       	andi	r24, 0x7F	; 127
pereadres2:	
 134:	84 bd       	out	0x24, r24	; 36
 136:	08 95       	ret

COM1C1:
 138:	84 b5       	in	r24, 0x24	; 36
 13a:	8f 7d       	andi	r24, 0xDF	; 223
 13c:	fb cf       	rjmp	.-10     	; 0x134 <turnOffPWM+0x34>

COM21:		
 13e:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
 142:	8f 77       	andi	r24, 0x7F	; 127

pereadres3:	
 144:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
		

 148:	08 95       	ret

COM0A1:		
 14a:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
 14e:	8f 7d       	andi	r24, 0xDF	; 223
 150:	f9 cf       	rjmp	.-14     	; 0x144 <turnOffPWM+0x44>

00000152 <digitalRead>:

	SREG = oldSREG;
}

int digitalRead(uint8_t pin)
{
 152:	cf 93       	push	r28
 154:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
 156:	28 2f       	mov	r18, r24
 158:	30 e0       	ldi	r19, 0x00	; 0
 15a:	f9 01       	movw	r30, r18
 15c:	e2 55       	subi	r30, 0x52	; 82
 15e:	ff 4f       	sbci	r31, 0xFF	; 255
 160:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
 162:	f9 01       	movw	r30, r18
 164:	e6 56       	subi	r30, 0x66	; 102
 166:	ff 4f       	sbci	r31, 0xFF	; 255
 168:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
 16a:	f9 01       	movw	r30, r18
 16c:	ea 57       	subi	r30, 0x7A	; 122
 16e:	ff 4f       	sbci	r31, 0xFF	; 255
 170:	c4 91       	lpm	r28, Z

	if (port == NOT_A_PIN) return LOW;
 172:	cc 23       	and	r28, r28
 174:	a1 f0       	breq	.+40     	; 0x19e <digitalRead+0x4c>

	// If the pin that support PWM output, we need to turn it off
	// before getting a digital reading.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 176:	81 11       	cpse	r24, r1
 178:	0e 94 80 00 	call	0x100	; 0x100 <turnOffPWM>

	if (*portInputRegister(port) & bit) return HIGH;
 17c:	ec 2f       	mov	r30, r28
 17e:	f0 e0       	ldi	r31, 0x00	; 0
 180:	ee 0f       	add	r30, r30
 182:	ff 1f       	adc	r31, r31
 184:	e4 58       	subi	r30, 0x84	; 132
 186:	ff 4f       	sbci	r31, 0xFF	; 255
 188:	a5 91       	lpm	r26, Z+
 18a:	b4 91       	lpm	r27, Z
 18c:	ec 91       	ld	r30, X
 18e:	ed 23       	and	r30, r29
 190:	81 e0       	ldi	r24, 0x01	; 1
 192:	90 e0       	ldi	r25, 0x00	; 0
 194:	09 f4       	brne	.+2      	; 0x198 <digitalRead+0x46>
 196:	80 e0       	ldi	r24, 0x00	; 0
	return LOW;
}
 198:	df 91       	pop	r29
 19a:	cf 91       	pop	r28
 19c:	08 95       	ret
{
	uint8_t timer = digitalPinToTimer(pin);
	uint8_t bit = digitalPinToBitMask(pin);
	uint8_t port = digitalPinToPort(pin);

	if (port == NOT_A_PIN) return LOW;
 19e:	80 e0       	ldi	r24, 0x00	; 0
 1a0:	90 e0       	ldi	r25, 0x00	; 0
 1a2:	fa cf       	rjmp	.-12     	; 0x198 <digitalRead+0x46>

000001a4 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
 1a4:	1f 93       	push	r17
 1a6:	cf 93       	push	r28
 1a8:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
 1aa:	28 2f       	mov	r18, r24
 1ac:	30 e0       	ldi	r19, 0x00	; 0
 1ae:	f9 01       	movw	r30, r18
 1b0:	e2 55       	subi	r30, 0x52	; 82
 1b2:	ff 4f       	sbci	r31, 0xFF	; 255
 1b4:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
 1b6:	f9 01       	movw	r30, r18
 1b8:	e6 56       	subi	r30, 0x66	; 102
 1ba:	ff 4f       	sbci	r31, 0xFF	; 255
 1bc:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
 1be:	f9 01       	movw	r30, r18
 1c0:	ea 57       	subi	r30, 0x7A	; 122
 1c2:	ff 4f       	sbci	r31, 0xFF	; 255
 1c4:	c4 91       	lpm	r28, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
 1c6:	cc 23       	and	r28, r28
 1c8:	a9 f0       	breq	.+42     	; 0x1f4 <digitalWrite+0x50>
 1ca:	16 2f       	mov	r17, r22

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 1cc:	81 11       	cpse	r24, r1
 1ce:	0e 94 80 00 	call	0x100	; 0x100 <turnOffPWM>

	out = portOutputRegister(port);
 1d2:	ec 2f       	mov	r30, r28
 1d4:	f0 e0       	ldi	r31, 0x00	; 0
 1d6:	ee 0f       	add	r30, r30
 1d8:	ff 1f       	adc	r31, r31
 1da:	ee 58       	subi	r30, 0x8E	; 142
 1dc:	ff 4f       	sbci	r31, 0xFF	; 255
 1de:	a5 91       	lpm	r26, Z+
 1e0:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
 1e2:	8f b7       	in	r24, 0x3f	; 63
	cli();
 1e4:	f8 94       	cli

	if (val == LOW) {
		*out &= ~bit;
 1e6:	ec 91       	ld	r30, X
	out = portOutputRegister(port);

	uint8_t oldSREG = SREG;
	cli();

	if (val == LOW) {
 1e8:	11 11       	cpse	r17, r1
 1ea:	08 c0       	rjmp	.+16     	; 0x1fc <digitalWrite+0x58>
		*out &= ~bit;
 1ec:	d0 95       	com	r29
 1ee:	de 23       	and	r29, r30
	} else {
		*out |= bit;
 1f0:	dc 93       	st	X, r29
	}

	SREG = oldSREG;
 1f2:	8f bf       	out	0x3f, r24	; 63
}
 1f4:	df 91       	pop	r29
 1f6:	cf 91       	pop	r28
 1f8:	1f 91       	pop	r17
 1fa:	08 95       	ret
	cli();

	if (val == LOW) {
		*out &= ~bit;
	} else {
		*out |= bit;
 1fc:	de 2b       	or	r29, r30
 1fe:	f8 cf       	rjmp	.-16     	; 0x1f0 <digitalWrite+0x4c>

00000200 <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
 200:	cf 93       	push	r28
 202:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
 204:	90 e0       	ldi	r25, 0x00	; 0
 206:	fc 01       	movw	r30, r24
 208:	e6 56       	subi	r30, 0x66	; 102
 20a:	ff 4f       	sbci	r31, 0xFF	; 255
 20c:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
 20e:	8a 57       	subi	r24, 0x7A	; 122
 210:	9f 4f       	sbci	r25, 0xFF	; 255
 212:	fc 01       	movw	r30, r24
 214:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 216:	88 23       	and	r24, r24
 218:	d1 f0       	breq	.+52     	; 0x24e <pinMode+0x4e>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 21a:	90 e0       	ldi	r25, 0x00	; 0
 21c:	88 0f       	add	r24, r24
 21e:	99 1f       	adc	r25, r25
 220:	fc 01       	movw	r30, r24
 222:	e8 59       	subi	r30, 0x98	; 152
 224:	ff 4f       	sbci	r31, 0xFF	; 255
 226:	a5 91       	lpm	r26, Z+
 228:	b4 91       	lpm	r27, Z
	out = portOutputRegister(port);
 22a:	fc 01       	movw	r30, r24
 22c:	ee 58       	subi	r30, 0x8E	; 142
 22e:	ff 4f       	sbci	r31, 0xFF	; 255
 230:	c5 91       	lpm	r28, Z+
 232:	d4 91       	lpm	r29, Z

	if (mode == INPUT) { 
 234:	61 11       	cpse	r22, r1
 236:	0e c0       	rjmp	.+28     	; 0x254 <pinMode+0x54>
		uint8_t oldSREG = SREG;
 238:	9f b7       	in	r25, 0x3f	; 63
                cli();
 23a:	f8 94       	cli
		*reg &= ~bit;
 23c:	8c 91       	ld	r24, X
 23e:	e2 2f       	mov	r30, r18
 240:	e0 95       	com	r30
 242:	8e 23       	and	r24, r30
 244:	8c 93       	st	X, r24
		*out &= ~bit;
 246:	28 81       	ld	r18, Y
 248:	e2 23       	and	r30, r18
 24a:	e8 83       	st	Y, r30
		SREG = oldSREG;
 24c:	9f bf       	out	0x3f, r25	; 63
		uint8_t oldSREG = SREG;
                cli();
		*reg |= bit;
		SREG = oldSREG;
	}
}
 24e:	df 91       	pop	r29
 250:	cf 91       	pop	r28
 252:	08 95       	ret
                cli();
		*reg &= ~bit;
		*out |= bit;
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
 254:	8f b7       	in	r24, 0x3f	; 63
                cli();
 256:	f8 94       	cli
		*reg |= bit;
 258:	ec 91       	ld	r30, X
 25a:	e2 2b       	or	r30, r18
 25c:	ec 93       	st	X, r30
		SREG = oldSREG;
 25e:	8f bf       	out	0x3f, r24	; 63
 260:	f6 cf       	rjmp	.-20     	; 0x24e <pinMode+0x4e>

00000262 <micros>:
	return m;
}

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
 262:	3f b7       	in	r19, 0x3f	; 63
	
	cli();
 264:	f8 94       	cli
	m = timer0_overflow_count;
 266:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <timer0_overflow_count>
 26a:	90 91 08 01 	lds	r25, 0x0108	; 0x800108 <timer0_overflow_count+0x1>
 26e:	a0 91 09 01 	lds	r26, 0x0109	; 0x800109 <timer0_overflow_count+0x2>
 272:	b0 91 0a 01 	lds	r27, 0x010A	; 0x80010a <timer0_overflow_count+0x3>
#if defined(TCNT0)
	t = TCNT0;
 276:	26 b5       	in	r18, 0x26	; 38
#else
	#error TIMER 0 not defined
#endif

#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
 278:	a8 9b       	sbis	0x15, 0	; 21
 27a:	05 c0       	rjmp	.+10     	; 0x286 <micros+0x24>
 27c:	2f 3f       	cpi	r18, 0xFF	; 255
 27e:	19 f0       	breq	.+6      	; 0x286 <micros+0x24>
		m++;
 280:	01 96       	adiw	r24, 0x01	; 1
 282:	a1 1d       	adc	r26, r1
 284:	b1 1d       	adc	r27, r1
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
 286:	3f bf       	out	0x3f, r19	; 63
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
 288:	ba 2f       	mov	r27, r26
 28a:	a9 2f       	mov	r26, r25
 28c:	98 2f       	mov	r25, r24
 28e:	88 27       	eor	r24, r24
 290:	bc 01       	movw	r22, r24
 292:	cd 01       	movw	r24, r26
 294:	62 0f       	add	r22, r18
 296:	71 1d       	adc	r23, r1
 298:	81 1d       	adc	r24, r1
 29a:	91 1d       	adc	r25, r1
 29c:	42 e0       	ldi	r20, 0x02	; 2
 29e:	66 0f       	add	r22, r22
 2a0:	77 1f       	adc	r23, r23
 2a2:	88 1f       	adc	r24, r24
 2a4:	99 1f       	adc	r25, r25
 2a6:	4a 95       	dec	r20
 2a8:	d1 f7       	brne	.-12     	; 0x29e <micros+0x3c>
}
 2aa:	08 95       	ret

000002ac <delay>:

void delay(unsigned long ms)
{
 2ac:	8f 92       	push	r8
 2ae:	9f 92       	push	r9
 2b0:	af 92       	push	r10
 2b2:	bf 92       	push	r11
 2b4:	cf 92       	push	r12
 2b6:	df 92       	push	r13
 2b8:	ef 92       	push	r14
 2ba:	ff 92       	push	r15
 2bc:	4b 01       	movw	r8, r22
 2be:	5c 01       	movw	r10, r24
	uint32_t start = micros();
 2c0:	0e 94 31 01 	call	0x262	; 0x262 <micros>
 2c4:	6b 01       	movw	r12, r22
 2c6:	7c 01       	movw	r14, r24

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
 2c8:	0e 94 31 01 	call	0x262	; 0x262 <micros>
 2cc:	6c 19       	sub	r22, r12
 2ce:	7d 09       	sbc	r23, r13
 2d0:	8e 09       	sbc	r24, r14
 2d2:	9f 09       	sbc	r25, r15
 2d4:	68 3e       	cpi	r22, 0xE8	; 232
 2d6:	73 40       	sbci	r23, 0x03	; 3
 2d8:	81 05       	cpc	r24, r1
 2da:	91 05       	cpc	r25, r1
 2dc:	a8 f3       	brcs	.-22     	; 0x2c8 <delay+0x1c>
			ms--;
 2de:	21 e0       	ldi	r18, 0x01	; 1
 2e0:	82 1a       	sub	r8, r18
 2e2:	91 08       	sbc	r9, r1
 2e4:	a1 08       	sbc	r10, r1
 2e6:	b1 08       	sbc	r11, r1
			start += 1000;
 2e8:	88 ee       	ldi	r24, 0xE8	; 232
 2ea:	c8 0e       	add	r12, r24
 2ec:	83 e0       	ldi	r24, 0x03	; 3
 2ee:	d8 1e       	adc	r13, r24
 2f0:	e1 1c       	adc	r14, r1
 2f2:	f1 1c       	adc	r15, r1
{
	uint32_t start = micros();

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
 2f4:	81 14       	cp	r8, r1
 2f6:	91 04       	cpc	r9, r1
 2f8:	a1 04       	cpc	r10, r1
 2fa:	b1 04       	cpc	r11, r1
 2fc:	29 f7       	brne	.-54     	; 0x2c8 <delay+0x1c>
			ms--;
			start += 1000;
		}
	}
}
 2fe:	ff 90       	pop	r15
 300:	ef 90       	pop	r14
 302:	df 90       	pop	r13
 304:	cf 90       	pop	r12
 306:	bf 90       	pop	r11
 308:	af 90       	pop	r10
 30a:	9f 90       	pop	r9
 30c:	8f 90       	pop	r8
 30e:	08 95       	ret

00000310 <shiftOut.constprop.3>:
		digitalWrite(clockPin, LOW);
	}
	return value;
}

void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
 310:	cf 93       	push	r28
 312:	df 93       	push	r29
 314:	d8 2f       	mov	r29, r24
 316:	c8 e0       	ldi	r28, 0x08	; 8
{
	uint8_t i;

	for (i = 0; i < 8; i++)  {
		if (bitOrder == LSBFIRST) {
			digitalWrite(dataPin, val & 1);
 318:	6d 2f       	mov	r22, r29
 31a:	61 70       	andi	r22, 0x01	; 1
 31c:	8d e0       	ldi	r24, 0x0D	; 13
 31e:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
			val >>= 1;
 322:	d6 95       	lsr	r29
		} else {	
			digitalWrite(dataPin, (val & 128) != 0);
			val <<= 1;
		}
			
		digitalWrite(clockPin, HIGH);
 324:	61 e0       	ldi	r22, 0x01	; 1
 326:	8b e0       	ldi	r24, 0x0B	; 11
 328:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
		digitalWrite(clockPin, LOW);		
 32c:	60 e0       	ldi	r22, 0x00	; 0
 32e:	8b e0       	ldi	r24, 0x0B	; 11
 330:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
 334:	c1 50       	subi	r28, 0x01	; 1

void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
{
	uint8_t i;

	for (i = 0; i < 8; i++)  {
 336:	81 f7       	brne	.-32     	; 0x318 <shiftOut.constprop.3+0x8>
		}
			
		digitalWrite(clockPin, HIGH);
		digitalWrite(clockPin, LOW);		
	}
}
 338:	df 91       	pop	r29
 33a:	cf 91       	pop	r28
 33c:	08 95       	ret

0000033e <shiftIn.constprop.2>:
  Boston, MA  02111-1307  USA
*/

#include "wiring_private.h"

uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
 33e:	1f 93       	push	r17
 340:	cf 93       	push	r28
 342:	df 93       	push	r29
 344:	d0 e0       	ldi	r29, 0x00	; 0
 346:	c0 e0       	ldi	r28, 0x00	; 0
	uint8_t value = 0;
 348:	10 e0       	ldi	r17, 0x00	; 0
	uint8_t i;

	for (i = 0; i < 8; ++i) {
		digitalWrite(clockPin, HIGH);
 34a:	61 e0       	ldi	r22, 0x01	; 1
 34c:	86 e0       	ldi	r24, 0x06	; 6
 34e:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
		if (bitOrder == LSBFIRST)
			value |= digitalRead(dataPin) << i;
 352:	85 e0       	ldi	r24, 0x05	; 5
 354:	0e 94 a9 00 	call	0x152	; 0x152 <digitalRead>
 358:	0c 2e       	mov	r0, r28
 35a:	01 c0       	rjmp	.+2      	; 0x35e <shiftIn.constprop.2+0x20>
 35c:	88 0f       	add	r24, r24
 35e:	0a 94       	dec	r0
 360:	ea f7       	brpl	.-6      	; 0x35c <shiftIn.constprop.2+0x1e>
 362:	18 2b       	or	r17, r24
		else
			value |= digitalRead(dataPin) << (7 - i);
		digitalWrite(clockPin, LOW);
 364:	60 e0       	ldi	r22, 0x00	; 0
 366:	86 e0       	ldi	r24, 0x06	; 6
 368:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
 36c:	21 96       	adiw	r28, 0x01	; 1

uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
	uint8_t value = 0;
	uint8_t i;

	for (i = 0; i < 8; ++i) {
 36e:	c8 30       	cpi	r28, 0x08	; 8
 370:	d1 05       	cpc	r29, r1
 372:	59 f7       	brne	.-42     	; 0x34a <shiftIn.constprop.2+0xc>
		else
			value |= digitalRead(dataPin) << (7 - i);
		digitalWrite(clockPin, LOW);
	}
	return value;
}
 374:	81 2f       	mov	r24, r17
 376:	df 91       	pop	r29
 378:	cf 91       	pop	r28
 37a:	1f 91       	pop	r17
 37c:	08 95       	ret

0000037e <_Z5checkhPhS_>:
   
   delay(10); 
}

void check(byte data, uint8_t *in1, uint8_t *in2)
{
 37e:	ef 92       	push	r14
 380:	ff 92       	push	r15
 382:	0f 93       	push	r16
 384:	1f 93       	push	r17
 386:	cf 93       	push	r28
 388:	df 93       	push	r29
 38a:	c8 2f       	mov	r28, r24
 38c:	7b 01       	movw	r14, r22
 38e:	8a 01       	movw	r16, r20
  //записывание
   digitalWrite(latchPin, LOW);//дергаем защелку, нвчинаем передавать бит
 390:	60 e0       	ldi	r22, 0x00	; 0
 392:	8c e0       	ldi	r24, 0x0C	; 12
 394:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
   shiftOut(dataPin, clockPin, LSBFIRST, data);
 398:	8c 2f       	mov	r24, r28
 39a:	0e 94 88 01 	call	0x310	; 0x310 <shiftOut.constprop.3>
   shiftOut(dataPin, clockPin, LSBFIRST, data);
 39e:	8c 2f       	mov	r24, r28
 3a0:	0e 94 88 01 	call	0x310	; 0x310 <shiftOut.constprop.3>
   digitalWrite(latchPin, HIGH); // сигнализуруем, что больше не надо считывать
 3a4:	61 e0       	ldi	r22, 0x01	; 1
 3a6:	8c e0       	ldi	r24, 0x0C	; 12
 3a8:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>

   //дергаем защелку, чтобы захватить состояния выходов
   digitalWrite(latchIn, LOW);
 3ac:	60 e0       	ldi	r22, 0x00	; 0
 3ae:	87 e0       	ldi	r24, 0x07	; 7
 3b0:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
	

#endif

	// busy wait
	__asm__ __volatile__ (
 3b4:	cf e0       	ldi	r28, 0x0F	; 15
 3b6:	d0 e0       	ldi	r29, 0x00	; 0
 3b8:	ce 01       	movw	r24, r28
 3ba:	01 97       	sbiw	r24, 0x01	; 1
 3bc:	f1 f7       	brne	.-4      	; 0x3ba <_Z5checkhPhS_+0x3c>
   delayMicroseconds(5);
   digitalWrite(latchIn, HIGH);
 3be:	61 e0       	ldi	r22, 0x01	; 1
 3c0:	87 e0       	ldi	r24, 0x07	; 7
 3c2:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
 3c6:	21 97       	sbiw	r28, 0x01	; 1
 3c8:	f1 f7       	brne	.-4      	; 0x3c6 <_Z5checkhPhS_+0x48>
   delayMicroseconds(5);
  
   //считывание
   digitalWrite(clockIn, HIGH); //без этого не считывает последний бит
 3ca:	61 e0       	ldi	r22, 0x01	; 1
 3cc:	86 e0       	ldi	r24, 0x06	; 6
 3ce:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
   digitalWrite(clockEnableIn, LOW); //дергаем запись, начинаем считывать бит
 3d2:	60 e0       	ldi	r22, 0x00	; 0
 3d4:	84 e0       	ldi	r24, 0x04	; 4
 3d6:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
   *in1=shiftIn(dataIn, clockIn, LSBFIRST);
 3da:	0e 94 9f 01 	call	0x33e	; 0x33e <shiftIn.constprop.2>
 3de:	f7 01       	movw	r30, r14
 3e0:	80 83       	st	Z, r24
   *in2=shiftIn(dataIn, clockIn, LSBFIRST);
 3e2:	0e 94 9f 01 	call	0x33e	; 0x33e <shiftIn.constprop.2>
 3e6:	f8 01       	movw	r30, r16
 3e8:	80 83       	st	Z, r24
   digitalWrite(clockEnableIn, HIGH); //сигнализируем, что больше не надо считывать   
 3ea:	61 e0       	ldi	r22, 0x01	; 1
 3ec:	84 e0       	ldi	r24, 0x04	; 4
}
 3ee:	df 91       	pop	r29
 3f0:	cf 91       	pop	r28
 3f2:	1f 91       	pop	r17
 3f4:	0f 91       	pop	r16
 3f6:	ff 90       	pop	r15
 3f8:	ef 90       	pop	r14
   //считывание
   digitalWrite(clockIn, HIGH); //без этого не считывает последний бит
   digitalWrite(clockEnableIn, LOW); //дергаем запись, начинаем считывать бит
   *in1=shiftIn(dataIn, clockIn, LSBFIRST);
   *in2=shiftIn(dataIn, clockIn, LSBFIRST);
   digitalWrite(clockEnableIn, HIGH); //сигнализируем, что больше не надо считывать   
 3fa:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <digitalWrite>

000003fe <__vector_16>:
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 3fe:	1f 92       	push	r1
 400:	0f 92       	push	r0
 402:	0f b6       	in	r0, 0x3f	; 63
 404:	0f 92       	push	r0
 406:	11 24       	eor	r1, r1
 408:	2f 93       	push	r18
 40a:	3f 93       	push	r19
 40c:	8f 93       	push	r24
 40e:	9f 93       	push	r25
 410:	af 93       	push	r26
 412:	bf 93       	push	r27
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 414:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <timer0_millis>
 418:	90 91 04 01 	lds	r25, 0x0104	; 0x800104 <timer0_millis+0x1>
 41c:	a0 91 05 01 	lds	r26, 0x0105	; 0x800105 <timer0_millis+0x2>
 420:	b0 91 06 01 	lds	r27, 0x0106	; 0x800106 <timer0_millis+0x3>
	unsigned char f = timer0_fract;
 424:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__data_end>

	m += MILLIS_INC;
	f += FRACT_INC;
 428:	23 e0       	ldi	r18, 0x03	; 3
 42a:	23 0f       	add	r18, r19
	if (f >= FRACT_MAX) {
 42c:	2d 37       	cpi	r18, 0x7D	; 125
 42e:	58 f5       	brcc	.+86     	; 0x486 <__LOCK_REGION_LENGTH__+0x86>
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 430:	01 96       	adiw	r24, 0x01	; 1
 432:	a1 1d       	adc	r26, r1
 434:	b1 1d       	adc	r27, r1
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
		m += 1;
	}

	timer0_fract = f;
 436:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__data_end>
	timer0_millis = m;
 43a:	80 93 03 01 	sts	0x0103, r24	; 0x800103 <timer0_millis>
 43e:	90 93 04 01 	sts	0x0104, r25	; 0x800104 <timer0_millis+0x1>
 442:	a0 93 05 01 	sts	0x0105, r26	; 0x800105 <timer0_millis+0x2>
 446:	b0 93 06 01 	sts	0x0106, r27	; 0x800106 <timer0_millis+0x3>
	timer0_overflow_count++;
 44a:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <timer0_overflow_count>
 44e:	90 91 08 01 	lds	r25, 0x0108	; 0x800108 <timer0_overflow_count+0x1>
 452:	a0 91 09 01 	lds	r26, 0x0109	; 0x800109 <timer0_overflow_count+0x2>
 456:	b0 91 0a 01 	lds	r27, 0x010A	; 0x80010a <timer0_overflow_count+0x3>
 45a:	01 96       	adiw	r24, 0x01	; 1
 45c:	a1 1d       	adc	r26, r1
 45e:	b1 1d       	adc	r27, r1
 460:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <timer0_overflow_count>
 464:	90 93 08 01 	sts	0x0108, r25	; 0x800108 <timer0_overflow_count+0x1>
 468:	a0 93 09 01 	sts	0x0109, r26	; 0x800109 <timer0_overflow_count+0x2>
 46c:	b0 93 0a 01 	sts	0x010A, r27	; 0x80010a <timer0_overflow_count+0x3>
}
 470:	bf 91       	pop	r27
 472:	af 91       	pop	r26
 474:	9f 91       	pop	r25
 476:	8f 91       	pop	r24
 478:	3f 91       	pop	r19
 47a:	2f 91       	pop	r18
 47c:	0f 90       	pop	r0
 47e:	0f be       	out	0x3f, r0	; 63
 480:	0f 90       	pop	r0
 482:	1f 90       	pop	r1
 484:	18 95       	reti
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 486:	26 e8       	ldi	r18, 0x86	; 134
 488:	23 0f       	add	r18, r19
		m += 1;
 48a:	02 96       	adiw	r24, 0x02	; 2
 48c:	a1 1d       	adc	r26, r1
 48e:	b1 1d       	adc	r27, r1
 490:	d2 cf       	rjmp	.-92     	; 0x436 <__LOCK_REGION_LENGTH__+0x36>

00000492 <main>:

void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
 492:	cf 93       	push	r28
 494:	df 93       	push	r29
 496:	00 d0       	rcall	.+0      	; 0x498 <main+0x6>
 498:	cd b7       	in	r28, 0x3d	; 61
 49a:	de b7       	in	r29, 0x3e	; 62

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 49c:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 49e:	84 b5       	in	r24, 0x24	; 36
 4a0:	82 60       	ori	r24, 0x02	; 2
 4a2:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
 4a4:	84 b5       	in	r24, 0x24	; 36
 4a6:	81 60       	ori	r24, 0x01	; 1
 4a8:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 4aa:	85 b5       	in	r24, 0x25	; 37
 4ac:	82 60       	ori	r24, 0x02	; 2
 4ae:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
 4b0:	85 b5       	in	r24, 0x25	; 37
 4b2:	81 60       	ori	r24, 0x01	; 1
 4b4:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 4b6:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <__DATA_REGION_ORIGIN__+0xe>
 4ba:	81 60       	ori	r24, 0x01	; 1
 4bc:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__DATA_REGION_ORIGIN__+0xe>
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 4c0:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 4c4:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
 4c8:	82 60       	ori	r24, 0x02	; 2
 4ca:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 4ce:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
 4d2:	81 60       	ori	r24, 0x01	; 1
 4d4:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 4d8:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
 4dc:	81 60       	ori	r24, 0x01	; 1
 4de:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 4e2:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
 4e6:	84 60       	ori	r24, 0x04	; 4
 4e8:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 4ec:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
 4f0:	81 60       	ori	r24, 0x01	; 1
 4f2:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 4f6:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
 4fa:	84 60       	ori	r24, 0x04	; 4
 4fc:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
		sbi(ADCSRA, ADPS1);
 500:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
 504:	82 60       	ori	r24, 0x02	; 2
 506:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
		sbi(ADCSRA, ADPS0);
 50a:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
 50e:	81 60       	ori	r24, 0x01	; 1
 510:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 514:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
 518:	80 68       	ori	r24, 0x80	; 128
 51a:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 51e:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>

void setup() {
  // put your setup code here, to run once:

  //led
  pinMode(ledGreen, OUTPUT);
 522:	61 e0       	ldi	r22, 0x01	; 1
 524:	8a e0       	ldi	r24, 0x0A	; 10
 526:	0e 94 00 01 	call	0x200	; 0x200 <pinMode>
  pinMode(ledRed, OUTPUT);
 52a:	61 e0       	ldi	r22, 0x01	; 1
 52c:	88 e0       	ldi	r24, 0x08	; 8
 52e:	0e 94 00 01 	call	0x200	; 0x200 <pinMode>
  pinMode(ledYellow, OUTPUT);  
 532:	61 e0       	ldi	r22, 0x01	; 1
 534:	89 e0       	ldi	r24, 0x09	; 9
 536:	0e 94 00 01 	call	0x200	; 0x200 <pinMode>
   
  //165
  pinMode(latchIn, OUTPUT);
 53a:	61 e0       	ldi	r22, 0x01	; 1
 53c:	87 e0       	ldi	r24, 0x07	; 7
 53e:	0e 94 00 01 	call	0x200	; 0x200 <pinMode>
  pinMode(clockIn, OUTPUT);
 542:	61 e0       	ldi	r22, 0x01	; 1
 544:	86 e0       	ldi	r24, 0x06	; 6
 546:	0e 94 00 01 	call	0x200	; 0x200 <pinMode>
  pinMode(dataIn, INPUT);
 54a:	60 e0       	ldi	r22, 0x00	; 0
 54c:	85 e0       	ldi	r24, 0x05	; 5
 54e:	0e 94 00 01 	call	0x200	; 0x200 <pinMode>
  pinMode(clockEnableIn, OUTPUT);
 552:	61 e0       	ldi	r22, 0x01	; 1
 554:	84 e0       	ldi	r24, 0x04	; 4
 556:	0e 94 00 01 	call	0x200	; 0x200 <pinMode>

  //595
  pinMode(latchPin, OUTPUT);
 55a:	61 e0       	ldi	r22, 0x01	; 1
 55c:	8c e0       	ldi	r24, 0x0C	; 12
 55e:	0e 94 00 01 	call	0x200	; 0x200 <pinMode>
  pinMode(dataPin, OUTPUT);
 562:	61 e0       	ldi	r22, 0x01	; 1
 564:	8d e0       	ldi	r24, 0x0D	; 13
 566:	0e 94 00 01 	call	0x200	; 0x200 <pinMode>
  pinMode(clockPin, OUTPUT);
 56a:	61 e0       	ldi	r22, 0x01	; 1
 56c:	8b e0       	ldi	r24, 0x0B	; 11
 56e:	0e 94 00 01 	call	0x200	; 0x200 <pinMode>

  //настройки
  pinMode(regim, INPUT);
 572:	60 e0       	ldi	r22, 0x00	; 0
 574:	83 e0       	ldi	r24, 0x03	; 3
 576:	0e 94 00 01 	call	0x200	; 0x200 <pinMode>
  pinMode(vcc, INPUT);
 57a:	60 e0       	ldi	r22, 0x00	; 0
 57c:	82 e0       	ldi	r24, 0x02	; 2
 57e:	0e 94 00 01 	call	0x200	; 0x200 <pinMode>
  pinMode(for_check, INPUT);
 582:	60 e0       	ldi	r22, 0x00	; 0
 584:	8f e0       	ldi	r24, 0x0F	; 15
 586:	0e 94 00 01 	call	0x200	; 0x200 <pinMode>

  //начальная установка
   digitalWrite(latchPin, LOW);//дергаем защелку, нвчинаем передавать бит
 58a:	60 e0       	ldi	r22, 0x00	; 0
 58c:	8c e0       	ldi	r24, 0x0C	; 12
 58e:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
   shiftOut(dataPin, clockPin, LSBFIRST, 0);
 592:	80 e0       	ldi	r24, 0x00	; 0
 594:	0e 94 88 01 	call	0x310	; 0x310 <shiftOut.constprop.3>
   shiftOut(dataPin, clockPin, LSBFIRST, 0);
 598:	80 e0       	ldi	r24, 0x00	; 0
 59a:	0e 94 88 01 	call	0x310	; 0x310 <shiftOut.constprop.3>
   digitalWrite(latchPin, HIGH); // сигнализуруем, что больше не надо считывать
 59e:	61 e0       	ldi	r22, 0x01	; 1
 5a0:	8c e0       	ldi	r24, 0x0C	; 12
 5a2:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
	

#endif

	// busy wait
	__asm__ __volatile__ (
 5a6:	0f e0       	ldi	r16, 0x0F	; 15
 5a8:	10 e0       	ldi	r17, 0x00	; 0
	
	setup();
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
 5aa:	80 e0       	ldi	r24, 0x00	; 0
 5ac:	c8 2e       	mov	r12, r24
 5ae:	80 e0       	ldi	r24, 0x00	; 0
 5b0:	d8 2e       	mov	r13, r24
           number++; //следующая проверка
         } //if
         else
         {
          digitalWrite(ledRed, HIGH);//не исправно
          number=5;//заканчиваем проверку
 5b2:	95 e0       	ldi	r25, 0x05	; 5
 5b4:	79 2e       	mov	r7, r25

void loop() {
  // put your main code here, to run repeatedly:
  uint8_t in1;
  uint8_t in2;
  int s1=digitalRead(regim);
 5b6:	83 e0       	ldi	r24, 0x03	; 3
 5b8:	0e 94 a9 00 	call	0x152	; 0x152 <digitalRead>
 5bc:	4c 01       	movw	r8, r24
  int s2=digitalRead(vcc);
 5be:	82 e0       	ldi	r24, 0x02	; 2
 5c0:	0e 94 a9 00 	call	0x152	; 0x152 <digitalRead>
 5c4:	7c 01       	movw	r14, r24
  int s3=digitalRead(for_check);
 5c6:	8f e0       	ldi	r24, 0x0F	; 15
 5c8:	0e 94 a9 00 	call	0x152	; 0x152 <digitalRead>
 5cc:	5c 01       	movw	r10, r24
  
  if (s1==0) //режим диагностика
  {
    if (s2==0) //не подключено проверяемое устройство
    {
      digitalWrite(ledRed, LOW);// все диоды потушить
 5ce:	60 e0       	ldi	r22, 0x00	; 0
  uint8_t in2;
  int s1=digitalRead(regim);
  int s2=digitalRead(vcc);
  int s3=digitalRead(for_check);
  
  if (s1==0) //режим диагностика
 5d0:	89 28       	or	r8, r9
 5d2:	09 f0       	breq	.+2      	; 0x5d6 <main+0x144>
 5d4:	65 c0       	rjmp	.+202    	; 0x6a0 <main+0x20e>
  {
    if (s2==0) //не подключено проверяемое устройство
    {
      digitalWrite(ledRed, LOW);// все диоды потушить
 5d6:	88 e0       	ldi	r24, 0x08	; 8
  int s2=digitalRead(vcc);
  int s3=digitalRead(for_check);
  
  if (s1==0) //режим диагностика
  {
    if (s2==0) //не подключено проверяемое устройство
 5d8:	ef 28       	or	r14, r15
 5da:	09 f0       	breq	.+2      	; 0x5de <main+0x14c>
 5dc:	56 c0       	rjmp	.+172    	; 0x68a <main+0x1f8>
    {
      digitalWrite(ledRed, LOW);// все диоды потушить
 5de:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
      digitalWrite(ledYellow, LOW);
 5e2:	60 e0       	ldi	r22, 0x00	; 0
 5e4:	89 e0       	ldi	r24, 0x09	; 9
 5e6:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
      digitalWrite(ledGreen, LOW);
 5ea:	60 e0       	ldi	r22, 0x00	; 0
 5ec:	8a e0       	ldi	r24, 0x0A	; 10
 5ee:	0e 94 d2 00 	call	
0x1a4	; 0x1a4 <digitalWrite>
}

void diagnostic()
{
  //записывание
   digitalWrite(latchPin, LOW);//дергаем защелку, нвчинаем передавать бит
 5f2:	60 e0       	ldi	r22, 0x00	; 0
 5f4:	8c e0       	ldi	r24, 0x0C	; 12
 5f6:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
   //сдвигаем байт данных по одному биту за раз, записывая на вывод данных
   shiftOut(dataPin, clockPin, LSBFIRST, 0);
 5fa:	80 e0       	ldi	r24, 0x00	; 0
 5fc:	0e 94 88 01 	call	0x310	; 0x310 <shiftOut.constprop.3>
   //у нас 16 разрядов - 2 байта, поэтому 2 функции
   shiftOut(dataPin, clockPin, LSBFIRST, 0);
 600:	80 e0       	ldi	r24, 0x00	; 0
 602:	0e 94 88 01 	call	0x310	; 0x310 <shiftOut.constprop.3>
   digitalWrite(latchPin, HIGH); // сигнализуруем, что больше не надо считывать
 606:	61 e0       	ldi	r22, 0x01	; 1
 608:	8c e0       	ldi	r24, 0x0C	; 12
 60a:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>

  //дергаем защелку, чтобы захватить состояния выходов
   digitalWrite(latchIn, LOW);
 60e:	60 e0       	ldi	r22, 0x00	; 0
 610:	87 e0       	ldi	r24, 0x07	; 7
 612:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
 616:	c8 01       	movw	r24, r16
 618:	01 97       	sbiw	r24, 0x01	; 1
 61a:	f1 f7       	brne	.-4      	; 0x618 <main+0x186>
   delayMicroseconds(5);
   digitalWrite(latchIn, HIGH);
 61c:	61 e0       	ldi	r22, 0x01	; 1
 61e:	87 e0       	ldi	r24, 0x07	; 7
 620:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
 624:	c8 01       	movw	r24, r16
 626:	01 97       	sbiw	r24, 0x01	; 1
 628:	f1 f7       	brne	.-4      	; 0x626 <main+0x194>
   delayMicroseconds(5);
  
   //считывание
   digitalWrite(clockIn, HIGH); //без этого не считывает последний бит
 62a:	61 e0       	ldi	r22, 0x01	; 1
 62c:	86 e0       	ldi	r24, 0x06	; 6
 62e:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
   digitalWrite(clockEnableIn, LOW); //дергаем запись, начинаем считывать бит
 632:	60 e0       	ldi	r22, 0x00	; 0
 634:	84 e0       	ldi	r24, 0x04	; 4
 636:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
   //сдвигаем байт данных по одному за раз, записывая на ввод данных
   uint8_t in1=shiftIn(dataIn, clockIn, LSBFIRST);
 63a:	0e 94 9f 01 	call	0x33e	; 0x33e <shiftIn.constprop.2>
 63e:	f8 2e       	mov	r15, r24
   uint8_t in2=shiftIn(dataIn, clockIn, LSBFIRST);
 640:	0e 94 9f 01 	call	0x33e	; 0x33e <shiftIn.constprop.2>
 644:	e8 2e       	mov	r14, r24
   digitalWrite(clockEnableIn, HIGH); //сигнализируем, что больше не надо считывать
 646:	61 e0       	ldi	r22, 0x01	; 1
 648:	84 e0       	ldi	r24, 0x04	; 4
 64a:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>


   //записывание
   digitalWrite(latchPin, LOW);//дергаем защелку, нвчинаем передавать бит
 64e:	60 e0       	ldi	r22, 0x00	; 0
 650:	8c e0       	ldi	r24, 0x0C	; 12
 652:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
   shiftOut(dataPin, clockPin, LSBFIRST, in2);
 656:	8e 2d       	mov	r24, r14
 658:	0e 94 88 01 	call	0x310	; 0x310 <shiftOut.constprop.3>
   shiftOut(dataPin, clockPin, LSBFIRST, in1);
 65c:	8f 2d       	mov	r24, r15
 65e:	0e 94 88 01 	call	0x310	; 0x310 <shiftOut.constprop.3>
   digitalWrite(latchPin, HIGH); // сигнализуруем, что больше не надо считывать
 662:	61 e0       	ldi	r22, 0x01	; 1
 664:	8c e0       	ldi	r24, 0x0C	; 12
 666:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>

   
   delay(10); 
 66a:	6a e0       	ldi	r22, 0x0A	; 10
 66c:	70 e0       	ldi	r23, 0x00	; 0
 66e:	80 e0       	ldi	r24, 0x00	; 0
 670:	90 e0       	ldi	r25, 0x00	; 0
 672:	0e 94 56 01 	call	0x2ac	; 0x2ac <delay>
    {
      digitalWrite(ledRed, LOW);
      digitalWrite(ledYellow, HIGH); //зажечь желтый диод - диагностика не возможна
      digitalWrite(ledGreen, LOW);
    }
    number=1; //номер проверки =1
 676:	81 e0       	ldi	r24, 0x01	; 1
 678:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
 67c:	c1 14       	cp	r12, r1
 67e:	d1 04       	cpc	r13, r1
 680:	09 f4       	brne	.+2      	; 0x684 <main+0x1f2>
 682:	99 cf       	rjmp	.-206    	; 0x5b6 <main+0x124>
 684:	0e 94 00 00 	call	0	; 0x0 <__vectors>
 688:	96 cf       	rjmp	.-212    	; 0x5b6 <main+0x124>
      diagnostic(); //диагностика
      
    }
    else //проверяемое устройство подключено
    {
      digitalWrite(ledRed, LOW);
 68a:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
      digitalWrite(ledYellow, HIGH); //зажечь желтый диод - диагностика не возможна
 68e:	61 e0       	ldi	r22, 0x01	; 1
 690:	89 e0       	ldi	r24, 0x09	; 9
 692:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
      digitalWrite(ledGreen, LOW);
 696:	60 e0       	ldi	r22, 0x00	; 0
 698:	8a e0       	ldi	r24, 0x0A	; 10
 69a:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
 69e:	eb cf       	rjmp	.-42     	; 0x676 <main+0x1e4>
  }
  else //режим проверки
  {
    
    //подаем нули на входы
   digitalWrite(latchPin, LOW);//дергаем защелку, нвчинаем передавать бит
 6a0:	8c e0       	ldi	r24, 0x0C	; 12
 6a2:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
   shiftOut(dataPin, clockPin, LSBFIRST, 0);
 6a6:	80 e0       	ldi	r24, 0x00	; 0
 6a8:	0e 94 88 01 	call	0x310	; 0x310 <shiftOut.constprop.3>
   shiftOut(dataPin, clockPin, LSBFIRST, 0);
 6ac:	80 e0       	ldi	r24, 0x00	; 0
 6ae:	0e 94 88 01 	call	0x310	; 0x310 <shiftOut.constprop.3>
   digitalWrite(latchPin, HIGH); // сигнализуруем, что больше не надо считывать
 6b2:	61 e0       	ldi	r22, 0x01	; 1
 6b4:	8c e0       	ldi	r24, 0x0C	; 12
 6b6:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
}

void check_begining(uint8_t *in1, uint8_t *in2)
{
  //дергаем защелку, чтобы захватить состояния выходов
   digitalWrite(latchIn, LOW);
 6ba:	60 e0       	ldi	r22, 0x00	; 0
 6bc:	87 e0       	ldi	r24, 0x07	; 7
 6be:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
 6c2:	c8 01       	movw	r24, r16
 6c4:	01 97       	sbiw	r24, 0x01	; 1
 6c6:	f1 f7       	brne	.-4      	; 0x6c4 <main+0x232>
   delayMicroseconds(5);
   digitalWrite(latchIn, HIGH);
 6c8:	61 e0       	ldi	r22, 0x01	; 1
 6ca:	87 e0       	ldi	r24, 0x07	; 7
 6cc:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
 6d0:	c8 01       	movw	r24, r16
 6d2:	01 97       	sbiw	r24, 0x01	; 1
 6d4:	f1 f7       	brne	.-4      	; 0x6d2 <main+0x240>
   delayMicroseconds(5);
  
   //считывание
   digitalWrite(clockIn, HIGH); //без этого не считывает последний бит
 6d6:	61 e0       	ldi	r22, 0x01	; 1
 6d8:	86 e0       	ldi	r24, 0x06	; 6
 6da:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
   digitalWrite(clockEnableIn, LOW); //дергаем запись, начинаем считывать бит
 6de:	60 e0       	ldi	r22, 0x00	; 0
 6e0:	84 e0       	ldi	r24, 0x04	; 4
 6e2:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
   *in1=shiftIn(dataIn, clockIn, LSBFIRST);
 6e6:	0e 94 9f 01 	call	0x33e	; 0x33e <shiftIn.constprop.2>
 6ea:	8a 83       	std	Y+2, r24	; 0x02
   *in2=shiftIn(dataIn, clockIn, LSBFIRST);
 6ec:	0e 94 9f 01 	call	0x33e	; 0x33e <shiftIn.constprop.2>
 6f0:	89 83       	std	Y+1, r24	; 0x01
   digitalWrite(clockEnableIn, HIGH); //сигнализируем, что больше не надо считывать
 6f2:	61 e0       	ldi	r22, 0x01	; 1
 6f4:	84 e0       	ldi	r24, 0x04	; 4
 6f6:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
   shiftOut(dataPin, clockPin, LSBFIRST, 0);
   shiftOut(dataPin, clockPin, LSBFIRST, 0);
   digitalWrite(latchPin, HIGH); // сигнализуруем, что больше не надо считывать
   
   check_begining(&in1, &in2); //проеверяем все ли переключатели, задающие выходы в режиме диагностики, выключены
    if ((in1!=0 ||in2!=0) && number==1 || s2==0 ) //переключатели не выключены в момент первой проверки или проверяемое устройство не подключено
 6fa:	8a 81       	ldd	r24, Y+2	; 0x02
 6fc:	81 11       	cpse	r24, r1
 6fe:	03 c0       	rjmp	.+6      	; 0x706 <main+0x274>
 700:	89 81       	ldd	r24, Y+1	; 0x01
 702:	88 23       	and	r24, r24
 704:	21 f0       	breq	.+8      	; 0x70e <main+0x27c>
 706:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 70a:	81 30       	cpi	r24, 0x01	; 1
 70c:	11 f0       	breq	.+4      	; 0x712 <main+0x280>
 70e:	ef 28       	or	r14, r15
 710:	29 f4       	brne	.+10     	; 0x71c <main+0x28a>
    {
       digitalWrite(ledYellow, HIGH); //зажечь желтый диод - проверка не возможна
 712:	61 e0       	ldi	r22, 0x01	; 1
 714:	89 e0       	ldi	r24, 0x09	; 9
      else //сброс
      {
        number=1;
        digitalWrite(ledGreen, LOW);
         digitalWrite(ledYellow, LOW);
         digitalWrite(ledRed, LOW);
 716:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
 71a:	b0 cf       	rjmp	.-160    	; 0x67c <main+0x1ea>
    {
       digitalWrite(ledYellow, HIGH); //зажечь желтый диод - проверка не возможна
    }
    else //всё норм
    {
      if (s3==1)//начать проверку
 71c:	aa 94       	dec	r10
 71e:	ab 28       	or	r10, r11
 720:	09 f0       	breq	.+2      	; 0x724 <main+0x292>
 722:	be c0       	rjmp	.+380    	; 0x8a0 <main+0x40e>
      {
          switch(number) //номер проверки 
 724:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 728:	82 30       	cpi	r24, 0x02	; 2
 72a:	09 f4       	brne	.+2      	; 0x72e <main+0x29c>
 72c:	69 c0       	rjmp	.+210    	; 0x800 <main+0x36e>
 72e:	78 f4       	brcc	.+30     	; 0x74e <main+0x2bc>
 730:	81 30       	cpi	r24, 0x01	; 1
 732:	b1 f1       	breq	.+108    	; 0x7a0 <main+0x30e>
         break;
      }
      default:
      {
       //записывание
       digitalWrite(latchPin, LOW);//дергаем защелку, нвчинаем передавать бит 
 734:	60 e0       	ldi	r22, 0x00	; 0
 736:	8c e0       	ldi	r24, 0x0C	; 12
 738:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
       shiftOut(dataPin, clockPin, LSBFIRST, 0); //сброс входов
 73c:	80 e0       	ldi	r24, 0x00	; 0
 73e:	0e 94 88 01 	call	0x310	; 0x310 <shiftOut.constprop.3>
       shiftOut(dataPin, clockPin, LSBFIRST, 0);
 742:	80 e0       	ldi	r24, 0x00	; 0
 744:	0e 94 88 01 	call	0x310	; 0x310 <shiftOut.constprop.3>
       digitalWrite(latchPin, HIGH); // сигнализуруем, что больше не надо считывать 
 748:	61 e0       	ldi	r22, 0x01	; 1
 74a:	8c e0       	ldi	r24, 0x0C	; 12
 74c:	e4 cf       	rjmp	.-56     	; 0x716 <main+0x284>
    }
    else //всё норм
    {
      if (s3==1)//начать проверку
      {
          switch(number) //номер проверки 
 74e:	83 30       	cpi	r24, 0x03	; 3
 750:	09 f4       	brne	.+2      	; 0x754 <main+0x2c2>
 752:	7d c0       	rjmp	.+250    	; 0x84e <main+0x3bc>
 754:	84 30       	cpi	r24, 0x04	; 4
 756:	71 f7       	brne	.-36     	; 0x734 <main+0x2a2>
         break;
      }//3
      case 4:
      {
        
        digitalWrite(ledGreen, LOW);
 758:	60 e0       	ldi	r22, 0x00	; 0
 75a:	8a e0       	ldi	r24, 0x0A	; 10
 75c:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
         digitalWrite(ledYellow, LOW);
 760:	60 e0       	ldi	r22, 0x00	; 0
 762:	89 e0       	ldi	r24, 0x09	; 9
 764:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
         digitalWrite(ledGreen, LOW);
 768:	60 e0       	ldi	r22, 0x00	; 0
 76a:	8a e0       	ldi	r24, 0x0A	; 10
 76c:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
         delay(1000);
 770:	68 ee       	ldi	r22, 0xE8	; 232
 772:	73 e0       	ldi	r23, 0x03	; 3
 774:	80 e0       	ldi	r24, 0x00	; 0
 776:	90 e0       	ldi	r25, 0x00	; 0
 778:	0e 94 56 01 	call	0x2ac	; 0x2ac <delay>
         check(255, &in1, &in2);//проверка
 77c:	ae 01       	movw	r20, r28
 77e:	4f 5f       	subi	r20, 0xFF	; 255
 780:	5f 4f       	sbci	r21, 0xFF	; 255
 782:	be 01       	movw	r22, r28
 784:	6e 5f       	subi	r22, 0xFE	; 254
 786:	7f 4f       	sbci	r23, 0xFF	; 255
 788:	8f ef       	ldi	r24, 0xFF	; 255
 78a:	0e 94 bf 01 	call	0x37e	; 0x37e <_Z5checkhPhS_>
         
         

         if (in1==221 && in2==221 )
 78e:	8a 81       	ldd	r24, Y+2	; 0x02
 790:	8d 3d       	cpi	r24, 0xDD	; 221
 792:	49 f5       	brne	.+82     	; 0x7e6 <main+0x354>
 794:	89 81       	ldd	r24, Y+1	; 0x01
 796:	8d 3d       	cpi	r24, 0xDD	; 221
 798:	31 f5       	brne	.+76     	; 0x7e6 <main+0x354>
         {
           digitalWrite(ledGreen, HIGH);
 79a:	61 e0       	ldi	r22, 0x01	; 1
 79c:	8a e0       	ldi	r24, 0x0A	; 10
 79e:	25 c0       	rjmp	.+74     	; 0x7ea <main+0x358>
          switch(number) //номер проверки 
    {
      
        case 1:
      {
         digitalWrite(ledGreen, LOW);
 7a0:	60 e0       	ldi	r22, 0x00	; 0
 7a2:	8a e0       	ldi	r24, 0x0A	; 10
 7a4:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
         digitalWrite(ledYellow, LOW);
 7a8:	60 e0       	ldi	r22, 0x00	; 0
 7aa:	89 e0       	ldi	r24, 0x09	; 9
 7ac:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
         digitalWrite(ledGreen, LOW);
 7b0:	60 e0       	ldi	r22, 0x00	; 0
 7b2:	8a e0       	ldi	r24, 0x0A	; 10
 7b4:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>

         check(0, &in1, &in2);//проверка
 7b8:	ae 01       	movw	r20, r28
 7ba:	4f 5f       	subi	r20, 0xFF	; 255
 7bc:	5f 4f       	sbci	r21, 0xFF	; 255
 7be:	be 01       	movw	r22, r28
 7c0:	6e 5f       	subi	r22, 0xFE	; 254
 7c2:	7f 4f       	sbci	r23, 0xFF	; 255
 7c4:	80 e0       	ldi	r24, 0x00	; 0
 7c6:	0e 94 bf 01 	call	0x37e	; 0x37e <_Z5checkhPhS_>
         

         if (in1==0 && in2==0)//сравниваем полученные значения с эталонными
 7ca:	8a 81       	ldd	r24, Y+2	; 0x02
 7cc:	81 11       	cpse	r24, r1
 7ce:	0b c0       	rjmp	.+22     	; 0x7e6 <main+0x354>
 7d0:	89 81       	ldd	r24, Y+1	; 0x01
 7d2:	81 11       	cpse	r24, r1
 7d4:	08 c0       	rjmp	.+16     	; 0x7e6 <main+0x354>
         {
           digitalWrite(ledGreen, HIGH); //проверка прошла
 7d6:	61 e0       	ldi	r22, 0x01	; 1
 7d8:	8a e0       	ldi	r24, 0x0A	; 10
 7da:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
           number++; //следующая проверка
 7de:	82 e0       	ldi	r24, 0x02	; 2
        

         if (in1==136 && in2==136 )
         {
           digitalWrite(ledGreen, HIGH);
           number++;
 7e0:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
 7e4:	06 c0       	rjmp	.+12     	; 0x7f2 <main+0x360>
           digitalWrite(ledGreen, HIGH); //проверка прошла
           number++; //следующая проверка
         } //if
         else
         {
          digitalWrite(ledRed, HIGH);//не исправно
 7e6:	61 e0       	ldi	r22, 0x01	; 1
 7e8:	88 e0       	ldi	r24, 0x08	; 8
 7ea:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
          number=5;//заканчиваем проверку
 7ee:	70 92 00 01 	sts	0x0100, r7	; 0x800100 <__data_start>
         }//else
         delay(1000);
 7f2:	68 ee       	ldi	r22, 0xE8	; 232
 7f4:	73 e0       	ldi	r23, 0x03	; 3
 7f6:	80 e0       	ldi	r24, 0x00	; 0
 7f8:	90 e0       	ldi	r25, 0x00	; 0
 7fa:	0e 94 56 01 	call	0x2ac	; 0x2ac <delay>
 7fe:	3e cf       	rjmp	.-388    	; 0x67c <main+0x1ea>
         break;
      }//1
      case 2:
      {
        
        digitalWrite(ledGreen, LOW);
 800:	60 e0       	ldi	r22, 0x00	; 0
 802:	8a e0       	ldi	r24, 0x0A	; 10
 804:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
         digitalWrite(ledYellow, LOW);
 808:	60 e0       	ldi	r22, 0x00	; 0
 80a:	89 e0       	ldi	r24, 0x09	; 9
 80c:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
         digitalWrite(ledGreen, LOW);
 810:	60 e0       	ldi	r22, 0x00	; 0
 812:	8a e0       	ldi	r24, 0x0A	; 10
 814:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
         delay(1000);
 818:	68 ee       	ldi	r22, 0xE8	; 232
 81a:	73 e0       	ldi	r23, 0x03	; 3
 81c:	80 e0       	ldi	r24, 0x00	; 0
 81e:	90 e0       	ldi	r25, 0x00	; 0
 820:	0e 94 56 01 	call	0x2ac	; 0x2ac <delay>
         check(51, &in1, &in2);//проверка
 824:	ae 01       	movw	r20, r28
 826:	4f 5f       	subi	r20, 0xFF	; 255
 828:	5f 4f       	sbci	r21, 0xFF	; 255
 82a:	be 01       	movw	r22, r28
 82c:	6e 5f       	subi	r22, 0xFE	; 254
 82e:	7f 4f       	sbci	r23, 0xFF	; 255
 830:	83 e3       	ldi	r24, 0x33	; 51
 832:	0e 94 bf 01 	call	0x37e	; 0x37e <_Z5checkhPhS_>
         
         

         if (in1==51 && in2==51 )
 836:	8a 81       	ldd	r24, Y+2	; 0x02
 838:	83 33       	cpi	r24, 0x33	; 51
 83a:	a9 f6       	brne	.-86     	; 0x7e6 <main+0x354>
 83c:	89 81       	ldd	r24, Y+1	; 0x01
 83e:	83 33       	cpi	r24, 0x33	; 51
 840:	91 f6       	brne	.-92     	; 0x7e6 <main+0x354>
         {
           digitalWrite(ledGreen, HIGH);
 842:	61 e0       	ldi	r22, 0x01	; 1
 844:	8a e0       	ldi	r24, 0x0A	; 10
 846:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
           number++;
 84a:	83 e0       	ldi	r24, 0x03	; 3
 84c:	c9 cf       	rjmp	.-110    	; 0x7e0 <main+0x34e>
         break;
      }//2
      case 3:
      {
         
         digitalWrite(ledGreen, LOW);
 84e:	60 e0       	ldi	r22, 0x00	; 0
 850:	8a e0       	ldi	r24, 0x0A	; 10
 852:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
         digitalWrite(ledYellow, LOW);
 856:	60 e0       	ldi	r22, 0x00	; 0
 858:	89 e0       	ldi	r24, 0x09	; 9
 85a:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
         digitalWrite(ledGreen, LOW);
 85e:	60 e0       	ldi	r22, 0x00	; 0
 860:	8a e0       	ldi	r24, 0x0A	; 10
 862:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
         delay(1000);
 866:	68 ee       	ldi	r22, 0xE8	; 232
 868:	73 e0       	ldi	r23, 0x03	; 3
 86a:	80 e0       	ldi	r24, 0x00	; 0
 86c:	90 e0       	ldi	r25, 0x00	; 0
 86e:	0e 94 56 01 	call	0x2ac	; 0x2ac <delay>
         check(204, &in1, &in2);//проверка
 872:	ae 01       	movw	r20, r28
 874:	4f 5f       	subi	r20, 0xFF	; 255
 876:	5f 4f       	sbci	r21, 0xFF	; 255
 878:	be 01       	movw	r22, r28
 87a:	6e 5f       	subi	r22, 0xFE	; 254
 87c:	7f 4f       	sbci	r23, 0xFF	; 255
 87e:	8c ec       	ldi	r24, 0xCC	; 204
 880:	0e 94 bf 01 	call	0x37e	; 0x37e <_Z5checkhPhS_>
         
        

         if (in1==136 && in2==136 )
 884:	8a 81       	ldd	r24, Y+2	; 0x02
 886:	88 38       	cpi	r24, 0x88	; 136
 888:	09 f0       	breq	.+2      	; 0x88c <main+0x3fa>
 88a:	ad cf       	rjmp	.-166    	; 0x7e6 <main+0x354>
 88c:	89 81       	ldd	r24, Y+1	; 0x01
 88e:	88 38       	cpi	r24, 0x88	; 136
 890:	09 f0       	breq	.+2      	; 0x894 <main+0x402>
 892:	a9 cf       	rjmp	.-174    	; 0x7e6 <main+0x354>
         {
           digitalWrite(ledGreen, HIGH);
 894:	61 e0       	ldi	r22, 0x01	; 1
 896:	8a e0       	ldi	r24, 0x0A	; 10
 898:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
           number++;
 89c:	84 e0       	ldi	r24, 0x04	; 4
 89e:	a0 cf       	rjmp	.-192    	; 0x7e0 <main+0x34e>
      
    }//switch
      } // готовы к проверке
      else //сброс
      {
        number=1;
 8a0:	81 e0       	ldi	r24, 0x01	; 1
 8a2:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
        digitalWrite(ledGreen, LOW);
 8a6:	60 e0       	ldi	r22, 0x00	; 0
 8a8:	8a e0       	ldi	r24, 0x0A	; 10
 8aa:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
         digitalWrite(ledYellow, LOW);
 8ae:	60 e0       	ldi	r22, 0x00	; 0
 8b0:	89 e0       	ldi	r24, 0x09	; 9
 8b2:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <digitalWrite>
         digitalWrite(ledRed, LOW);
 8b6:	60 e0       	ldi	r22, 0x00	; 0
 8b8:	88 e0       	ldi	r24, 0x08	; 8
 8ba:	2d cf       	rjmp	.-422    	; 0x716 <main+0x284>

000008bc <_exit>:
 8bc:	f8 94       	cli

000008be <__stop_program>:
 8be:	ff cf       	rjmp	.-2      	; 0x8be <__stop_program>
